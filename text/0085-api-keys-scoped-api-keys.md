- Title: API Keys & Scoped API Keys
- Start Date: 2021-10-15
- Specification PR: [#85](https://github.com/meilisearch/specifications/pull/85)
- Discovery Issue: [#51](https://github.com/meilisearch/product/issues/51)

# API Keys & Scoped API Keys

## 1. Functional Specification

### I. Summary

Granular management of API keys is added to MeiliSearch. It is possible to restrict the access of an API key to certain actions on specific indexes.

The SDKs can generate `Scoped API Keys` inheriting from a MeiliSearch's `API key` generated to force filters during a search for an end-user. It allows users to have multi-tenant indexes and thus restricts access to documents depending on the end-user making the search request.

### II. Motivation

To make MeiliSearch more reliable for teams, we extend the management and the possibilities of restrictions of the `API Key` resource. Security is a critical need, often tricky to negotiate as the stakes are high for a company.

We solve the use of multi-tenant indexes with the help of `Scoped API Keys`. By managing this, we reduce one of the last major deal-breakers that makes users not choose MeiliSearch as a solution despite all our advantages.

Users regularly request Multi-Tenant API keys over time. Users today need to set up workarounds to meet this need. Some of them implement reverse-proxy or managed authentication systems like Hasura or Kong to filter what can and cannot be read. Others decide to use server code as a facade to implement the access restriction logic before requesting MeiliSearch. It is difficult to maintain, less efficient, and requires necessary skills that not everyone has.

### III. Glossary

| Term               | Definition |
|--------------------|------------|
| Master Key         | This is the master key that allows you to create other API keys. The master key is defined by the user when launching MeiliSearch. |
| API Key            | API keys are stored and managed from the endpoint `/keys` by the master key holder. These are the keys used by the technical teams to interact with MeiliSearch at the level of the client code. |
| Scoped API Key | These keys are not stored and managed by a MeiliSearch instance. They are generated for each end-user by the backend code from a MeiliSearch API Key. They are used by the end-users to only search the documents belonging to them. |
| Multi-Tenancy      | By multi-tenancy, we mean that an end-user only accesses data belonging to him within an index shared with other end-users. |

### IV. Personas

| Persona | Role |
|---------|------|
| Anna    | Anna has an `ssh` access to the MeiliSearch instance and manages it on a daily basis. |
| Mark    | Mark is a developer from the same company as Anna. He will implement the code to communicate with MeiliSearch to solve technical/product needs. |
| UserX   | UserX represents any end-user making a search from the frontend interfaces provided by the company who Anna and Mark work for. |

### V. `API Key` Explanations

#### Summary Key Points

- /keys endpoints becomes restricted to the master key.
- When a master key is set at MeiliSearch first-launch, we generate two pre-configured `API Key`. A `Default Search API Key` restricted to the search action and a `Default Admin API Key` to handle all operations (except managing API Keys) on MeiliSearch.
- New endpoints are added to manage the `API Key` resource.
- `API keys` can have restrictions on which methods can be accessed via an `actions` list, they can also `expireAt` a specific datetime and be restricted to a specific set of `indexes`.

#### Managing `API Key`

![](https://i.imgur.com/mAUFnNb.png)

`Anna` manages the MeiliSearch instance, she uses the master-key she defined at startup to generate an `API Key` resource for `Mark` so that he can use it in his client code to communicate with the MeiliSearch instance.

`Anna` has the possibility to define access rights to certain indexes, to define an expiration date and also authorized `actions` for an `API Key`. (See API Key Actions List Definition Part).

Only the master-key allows managing the API keys.

---

#### `API Key` object representation

| field   | type    | description                                      |
|---------|---------|--------------------------------------------------|
| key     | string  | The generated key. **Generated by MeiliSearch**. |
| actions | array   | A list of actions permitted for the key. `["*"]` for all actions. See Actions list definition part. |
| indexes  | array  | A list of indexes permitted for the key. `["*"]` for all indexes. |
| expiresAt | string | Represent the expiration date and time as `ISO-8601` format. `null` equals to no expiration time. |
| description | string  | A description for the key. `null` if empty. |
| createdAt | string | Represent the date and time as `ISO-8601` format when the API key has been created. **Generated by MeiliSearch** |
| updatedAt | string | Represent the date and time as `ISO-8601` format when the API key has been updated. **Generated by MeiliSearch** |

#### `POST`/`PUT` - `/keys` - API Key object payload definition

| field   | type    | required |description                     |
|---------|---------|----------|--------------------------------|
| actions | array | Required | A list of actions permitted for the API key. `["*"]` for all actions. **See Actions list definition part**. `*` character can be used as a wildcard. e.g. `documents.*` to authorize access on all documents endpoints. **Default**: `No default` |
| expiresAt | string | Required | The expiration date and time as `ISO-8601` format. `null` equals to no expiration time. **Default**: `No Default` |
| indexes  | array  |  Required | `[*]` for all indexes.  **Default**: `No Default` |
| description | string  | Optional | A description for the API key. **Default**: `null` |

#### Actions List Definition

> `:authorizedIndexes` can be any value extracted from the `indexes` field of an `API key` resource.

| name    | description |
|---------|-------------|
| search  | Provides access to `GET` and `POST` methods on `/indexes/:authorizedIndexes/search` routes. |
| documents.add | Provides access to `POST` and `PUT` on `/indexes/:authorizedIndexes/documents` routes. |
| documents.get | Provides access to `GET` methods on `/indexes/:authorizedIndexes/documents/` and `/indexes/:authorizedIndexes/documents/:documentId` routes. |
| documents.delete | Provides access to `DELETE` method on `indexes/:authorizedIndexes/documents/:documentId`, `indexes/:authorizedIndexes/documents/:documentId` and `POST` method on `indexes/:authorizedIndexes/documents/delete-batch` routes. |
| indexes.add | Provides access to `POST` `/indexes`. **‚ö†Ô∏è The newly created `index` is added to the `indexes` array for this key and all others keys having `[*]` as a value for `indexes`**. |
| indexes.get | Provides access to `GET` `/indexes` and `/indexes/:authorizedIndexes`. **‚ö†Ô∏èNon-authorized `indexes` are ommited from the response on `/indexes`**. |
| indexes.update | Provides access to `PUT` `/indexes/:authorizedIndexes` |
| indexes.delete | Provides access to `DELETE` `/indexes/:authorizedIndexes` |
| tasks.get | Provides access to `GET` `/tasks` and `/indexes/:indexUid/tasks` routes. |
| settings.get | Provides access to `GET` `/indexes/:authorizedIndexes/settings` and `/indexes/:authorizedIndexes/settings/*` routes. |
| settings.update | Provides access to `POST` `/indexes/:authorizedIndexes/settings` and `/indexes/:authorizedIndexes/settings/*` routes. |
| settings.reset | Provides access to `DELETE` `/indexes/:authorizedIndexes/settings` and `/indexes/:authorizedIndexes/settings/*` routes. |
| stats | Provides access to `GET` `/stats/`. **‚ö†Ô∏èNon-authorized `indexes` are ommited from the response on `/stats`**. Also add access to `GET` `indexes/:authorizedIndexes/stats`. |
| dumps | Provides access to `POST` `/dumps` and `GET` `/dumps/:dumpUid` routes. |

---

#### **As `Anna üë©`, I want to create an `API key` for `Mark üë®üèª` client-code, so that he can index  some documents into MeiliSearch**

##### Request Definition

`POST` - `/keys`

##### Headers

```
"X-MEILI-API-KEY: :masterKey"
"Content-Type: application/json"
```

##### Body Payload

```json
{
    "description": "Indexing Products API key",
    "indexes": ["products"],
    "actions": [
        "documents.add"
    ],
    "expiresAt": "2021-11-13T00:00:00Z"
}
```

##### Response

`200 Success`

```json
{
    "key": "d0552b41536279a0ad88bd595327b96f01176a60c2243e906c52ac02375f9bc4",
    "createdAt": "2021-11-12T10:00:00Z"
}
```

##### Requirements

- `actions` is mandatory and should be an array of valid `actions`.
- `indexes` is mandatory and should be an array of string.
- `expiresAt` is mandatory and must be a valid `ISO 8601` datetime in the future or `null`.
- If set, `description` should be a string or null.

---

#### **As `Anna üë©`, I want to get details about an `API Key`**

##### Request Definition

`GET` - `/keys/:key`

##### Headers

```
"X-MEILI-API-KEY: :masterKey"
```

##### Response

`200 Success`

```json
{
    "description": "Indexing API key",
    "key": "d0552b41536279a0ad88bd595327b96f01176a60c2243e906c52ac02375f9bc4",
    "actions": [
        "documents.add"
    ],
    "indexes": [
        "products"
    ],
    "expiresAt": "2021-11-13T00:00:00Z",
    "createdAt": "2021-11-12T10:00:00Z",
    "updatedAt": "2021-11-12T10:00:00Z"
}
```

##### Errors

- `404 API Key Not Found`

---

#### **As `Anna üë©`, I want to update API key to change its restrictions**

##### Request Definition

`PUT` - `/keys/:key`

##### Headers

```
"X-MEILI-API-KEY: :masterKey"
"Content-Type: application/json"
```

##### Body Payload

```json
{
    "description": "Manage Products/Reviews Documents API key",
    "indexes": ["products", "reviews"], //Has now access to reviews
    "actions": [
        "documents.*" //Has now access to all operations on the documents API endpoint
    ],
    "expiresAt": "2021-12-31T23:59:59Z" //Extended to the end of the year
}
```

> ‚ö†Ô∏è Any omitted fields are restored to his default value. See `POST`/`PUT` - `/keys` - API Key object payload definition part. Only `description` field is concerned so far.

##### Response

`200 Success`

```json
{
    "key": "d0552b41536279a0ad88bd595327b96f01176a60c2243e906c52ac02375f9bc4",
    "updatedAt": "2021-10-12T15:00:00Z"
}
```

##### Errors

- `404 API Key Not Found`.
- `actions` is mandatory and should be an array of valid `actions`.
- `indexes` is mandatory and should be an array of string.
- `expiresAt` is mandatory and must be a valid `ISO 8601` datetime in the future or `null`.
- If set, `description` should be a string or null.

---

#### **As `Anna`, I want to list the API Keys**

##### Request Definition

`GET` - `/keys`

##### Headers

```
"X-MEILI-API-KEY: :masterKey"
```

##### Response

`200 Success`

```json
{
    "results": [
        {
            "description": "Manage Products/Reviews Documents API key",
            "key": "d0552b41536279a0ad88bd595327b96f01176a60c2243e906c52ac02375f9bc4",
            "actions": [
                "documents.*"
            ],
            "indexes": [
                "products",
                "reviews"
            ],
            "expiresAt": "2021-12-31T23:59:59Z",
            "createdAt": "2021-10-12T00:00:00Z",
            "updatedAt": "2021-10-13T15:00:00Z"
        },
        {
            "description": "Default Search API Key (Use it to search from the frontend code)",
            "key": "0a6e572506c52ab0bd6195921575d23092b7f0c284ab4ac86d12346c33057f99",
            "actions": [
                "search"
            ],
            "indexes": [
                "*"
            ],
            "expiresInSeconds": null,
            "createdAt": "2021-08-11T10:00:00Z",
            "updatedAt": null
        },
        {
            "description": "Default Admin API Key (Do not expose it on frontend side)",
            "key": "380689dd379232519a54d15935750cc7625620a2ea2fc06907cb40ba5b421b6f",
            "actions": [
                "*"
            ],
            "indexes": [
                "*"
            ],
            "expiresInSeconds": null,
            "createdAt": "2021-08-11T10:00:00.000000Z",
            "updatedAt": null
        }
    ],
}
```

> Expired API keys cannot be found on the `/keys` endpoints. Anna has to create a new `API key`. This can be handled in the future with an archiving system or something else. See Future Possibilities part.

> üëâ Note the two default generated API keys. When a master key is set at MeiliSearch first-launch, we can generates two pre-configured `Stored API Keys`. A Default Search API Key restricted to the search action and a Default Admin API Key to handle all operations (except managing API Keys) on MeiliSearch.

##### List details
- Keys are ordered by createdAt in desc order. (Most recent first)
- Expired API Keys are omitted.
- No pagination yet. See Future Possibilities part.

##### Errors

- TBD

---

#### **As `Anna üë©`, I want to delete an API key**

##### Request Definition

`DELETE` - `/keys/:key`

##### Headers

```
"X-MEILI-API-KEY: :masterKey"
```

##### Response

`204 No-Content`

##### Errors

- `404 API Key Not Found`.

---

#### Using `API Key` on client-code

![](https://i.imgur.com/kRKcB43.png)

`Mark` receives the `API Key` transmitted by `Anna` on a secured channel. He uses it to authenticate the requests to MeiliSearch.

#### **As `Mark üë®üèª`, I am using an expired/deleted API Key**

#### Request example

`POST` - `/indexes/movies/search`

#### Headers

```
    "X-MEILI-API-KEY": ":apiKey"
```

#### Response

`403 Forbidden`

```json
{
    "message": "The API Key provided is invalid.",
    "code": "invalid_api_key",
    "type": "auth_error",
    "link": "https://docs.meilisearch.com/errors#invalid_api_key"
}
```

---

### **As `Mark üë®üèª`, I am using a valid API Key but permission is not sufficient to access the requested API resource**

#### Request example

`POST` - `/indexes/movies/search`

#### Headers

#### Response

`403 Forbidden`

```json
{
    "message": "The API Key provided does not have sufficient permissions to access the requested resource.",
    "code": "insufficient_permissions",
    "type": "auth_error",
    "link": "https://docs.meilisearch.com/errors#insufficient_permission"
}
```

### V. `Scoped API Key` Explanations

#### Summary Key Points

- `Scoped API keys` are generated from a MeiliSearch `API key` on the client's server code to resolve multi-tenancy use-case by restricting access to data within an index according to the criteria chosen by the team managing a MeiliSearch instance.
- These `Scoped API keys` can't be less restrictive than a parent `API key` and can only be used for the search action with a predefined forced filter field.
- These `Scoped API keys` are not stored and thus retrievable on MeiliSearch. This is why we highly advise setting an expiration time on that type of API key for security reasons.

#### Solving Multi-Tenancy with `Scoped API Keys`

![](https://i.imgur.com/J4jVe1n.png)

Now imagine that `Mark` is a developer for a SaaS platform. He would like to ensure that an end-user can only access his documents at search time. **His database contains many users and he hopes to have many more in the future.**

When a user registers, the backend-side client code generates a `Scoped API Key` specifically for that end-user so that he can only access his documents.

A `filter` parameter is set to restrict the search to document having a field `user_id` having the by the `user_id` as a value. This `filter` parameter is contained in the `Scoped API key` payload and cannot be modified during the search by the end-user making the request. `filter` can be made of any valid filters. e.g. `user_id = 10 and category = Romantic`

This `Scoped API Key` is generated from a parent `API key` used to salt the `Scoped API Key`. This permits, on the MeiliSearch side, to check permissions and access for an end-user using this `Scoped API Key` during a search request.

---

#### Generating a `Scoped API Key`

```javascript
const scopedApiKeyRestrictions = {
     "indexesPolicy": {
         "products": {
             "filter": "user_id = 1"
         },
         "reviews": {
             "filter": "user_id = 1 AND published = true"
         }
     },
    "expiresIn": 3600
}

export const generateScopedApiKey = () => {
  //pseudo-code
  //hash the parentApiKey
  //keep a prefix of X char of the hashed parentApiKey -> prefixKey const
  return (parentApiKey: string, restrictions: scopedApiKeyRestrictions): string => {
    const queryParameters = serializeQueryParameters(restrictions);

    const securedKey = crypto
      .createHmac('sha256', apiKey)
      .update(queryParameters)
      .digest('hex');

    return Buffer.from(prefixKey + securedKey + queryParameters).toString('base64');
  };
};
```

##### scopedApiKeyRestrictions

The format allows defining specific enforced search filters for accessible indexes (these indexes must be defined in the parent `Api Key` used to generate the `Scoped API key` and have the search action).

In case the user does not want to define specific filters for each index accessible to the end-user, he can use this syntax.

A policy per index allows overriding the `"*"` behavior.

The `scoped API Keys` also accept a number of seconds in the `expiresIn` field until they expire. This field should be mandatory and explicitly set to `null` if no expiration date and time is expressed. Security by design is the mantra.


```javascript
const scopedApiKeyRestrictions = {
     "indexesPolicy": {
         "*": { //all search on indexes different than reviews will have the enforced filter `user_id`
             "filter": "user_id = 1"
         },
         "reviews": {
             "filter": "user_id = 1 AND published = true"
         }
     },
    "expiresIn": null //No expiration time ‚ö†Ô∏è Is not recommended for security and quality of life reasons because the only way to revoke it is to delete the parent key
}
```

#### Validity

`Scoped API Keys` expire or are revoked when the parent `API Key` is deleted or expires.

## 2. Technical Aspects

### Synchronous write of `API Key` resources

Synchronous writing would make it possible to dissociate key management from the update store, which handles asynchronous writing.

This would be much simpler in terms of developer experience and quality of life for the person managing the `API Key` resources.

## 3. Future Possibilities

### `API Keys`

- Add a generated id field to paginate the list of API Key.
- Hard limit the number of API keys that can be stored by MeiliSearch.
- Have an "archive" state where manually deleted API Keys can be restored.
- Add rate-limiting per API Key.
- A restriction on the maximum offset/limit.
- Add search parameters restrictions for an API Key.

### `Scoped API Keys`

- Handle more search parameters restrictions.
- Extends `SCoped API Keys` to more than `search` action.